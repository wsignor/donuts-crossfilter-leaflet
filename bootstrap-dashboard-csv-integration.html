<!doctype html>
<!--[if lt IE 7]>
<html class="no-js lt-ie9 lt-ie8 lt-ie7" lang=""> <![endif]-->
<!--[if IE 7]>
<html class="no-js lt-ie9 lt-ie8" lang=""> <![endif]-->
<!--[if IE 8]>
<html class="no-js lt-ie9" lang=""> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="">
<!--<![endif]-->

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Geo charts</title>
    <meta name="description" content="Geo charts">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="apple-touch-icon" href="apple-icon.png">
    <link rel="shortcut icon" href="images/favicon.ico">

    <link rel="stylesheet" href="assets/css/normalize.css">
    <link rel="stylesheet" href="assets/css/bootstrap.min.css">
    <link rel="stylesheet" href="assets/css/font-awesome.min.css">
    <link rel="stylesheet" href="assets/css/themify-icons.css">
    <link rel="stylesheet" href="assets/css/flag-icon.min.css">
    <link rel="stylesheet" href="assets/css/cs-skin-elastic.css">
    <!-- <link rel="stylesheet" href="assets/css/bootstrap-select.less"> -->
    <link rel="stylesheet" href="assets/scss/style.css">
    <link href="assets/css/lib/vector-map/jqvmap.min.css" rel="stylesheet">

    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="leaflet.css" />
    <link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/MarkerCluster.css' rel='stylesheet' />
    <!-- <link href='MarkerCluster.css' rel='stylesheet' /> -->
    <link rel="stylesheet" href="clusterpies-dash.css" />
    <link rel="stylesheet" href="dc.min.css" />
    <!-- <link rel="stylesheet" href="https://npmcdn.com/leaflet@0.7.7/dist/leaflet.css"> -->
    <!-- <link rel="stylesheet" href="https://dc-js.github.io/dc.js/css/dc.min.css" /> -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u"
        crossorigin="anonymous"> -->
    <!-- <script type="text/javascript" src="https://cdn.jsdelivr.net/html5shiv/3.7.3/html5shiv.min.js"></script> -->


    <!-- <script src="http://cdn.leafletjs.com/leaflet-0.7.2/leaflet.js" charset="utf-8"></script> -->
    <script src="leaflet.js" charset="utf-8"></script>
    <!-- <script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-markercluster/v0.4.0/leaflet.markercluster.js'></script> -->
    <script src='leaflet.markercluster.js'></script>
    <!--<script src="https://dc-js.github.io/dc.js/js/d3.js"></script>-->
    <!-- <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script> -->
    <script src="d3.v3.min.js" charset="utf-8"></script>
    <!-- <script src="https://dc-js.github.io/dc.js/js/crossfilter.js"></script> -->
    <script src="crossfilter.js"></script>
    <!-- <script src="https://dc-js.github.io/dc.js/js/dc.js"></script> -->
    <script src="dc.js"></script>
    <!-- <script src="http://cdnjs.cloudflare.com/ajax/libs/dc/1.7.5/dc.css" /> -->

    <!-- <script src="dc.js"></script> -->
    <!--<script src="https://npmcdn.com/leaflet@0.7.7/dist/leaflet.js"></script>-->
    <!-- <script src="//api.tiles.mapbox.com/mapbox.js/plugins/turf/v3.0.11/turf.min.js"></script> -->
    <script src="turf.min.js"></script>
    <script src='csv2geojson.js'></script>
    <script src='underscore-min.js'></script>

</head>

<body>

    <!-- Left Panel -->

    <!-- Right Panel -->

    <div id="right-panel" class="right-panel">


        <div class="breadcrumbs">
            <div class="col-sm-4">
                <div class="page-header float-left">
                    <div class="page-title">
                        <!-- <h1>Multivariate data representation model</h1> -->
                        <h1>Modelo para representação de dados multivariados</h1>
                    </div>
                </div>
            </div>
            <div class="col-sm-8">
                <div class="page-header float-right">
                    <div class="page-title">
                        <ol class="breadcrumb text-right">
                            <li class="active">Geo charts</li>
                        </ol>
                    </div>
                </div>
            </div>
        </div>


        <div class="content mt-3">
            <div class="col-xl-6">
                <div class="card-body" style="height:670px;">
                    <div id="map">
                    </div>

                </div>
            </div>
            <div class="col-sm-6 col-lg-3">
                <div class="dc-data-count">
                </div>
                <button onclick="changeChart()" class="button" id="buttonUpdateChart">Donut chart</button>
            </div>


            <div class="col-sm-6 col-lg-3">
                <h4 id="chart-1-title">Chart 1</h4>
                <div id="chart-1"></div>
            </div>

            <div class="col-sm-6 col-lg-3">

                <h4 id="chart-2-title">Chart 2</h4>
                <div id="chart-2"></div>
            </div>

            <div class="col-sm-6 col-lg-3">
                <h4 id="chart-3-title">Chart 3</h4>
                <div id="chart-3"></div>
            </div>

            <div class="col-sm-6 col-lg-3">
                <h4 id="chart-4-title">Chart 4</h4>
                <div id="chart-4"></div>
                <!-- style="padding-top:20px;padding-left:50px" -->
            </div>

            <div class="col-sm-6 col-lg-3">
                <h4 id="chart-5-title">Chart 5</h4>
                <div id="chart-5"></div>
                <!-- style="padding-top:20px;padding-left:50px" -->
            </div>


        </div>
    </div>

    <script>

        //"use strict"
        var geojson,
            metadata,
            filePath = 'acidentes-2016.csv',
            columns = [],
            mapColumns = []
        var mapColumnDistinct = [],
            // injuries
            categoryField = 'TIPO_ACID', //This is the fieldname for marker category (used in the pie and legend)
            // accident-type
            iconField = 'FERIDOS', //This is the fieldame for marker icon
            // accident-type, date and injuries
            popupFields = ['TIPO_ACID', 'DATE', 'TEMPO', 'AUTO', 'TAXI', 'LOTACAO', 'ONIBUS_URB', 'ONIBUS_MET', 'ONIBUS_INT', 'CAMINHAO', 'MOTO', 'CARROCA', 'BICICLETA', 'DIA_SEM'], //Popup will display these fields
            tileServer = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            tileAttribution = 'Map data: <a href="http://openstreetmap.org">OSM</a>',
            rmax = 30, //Maximum radius for cluster pies
            map = L.map('map').setView([59.95, 10.78], 8);
        var objects = [];
        var multiMap = false;
        var chartType;

        //L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', { foo: 'bar' }).addTo(map);
        L.tileLayer('https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png', { foo: 'bar' }).addTo(map);
        //map.addLayer(markerclusters);


        // load map properties selected in the previous html
        console.log(localStorage.getItem('mapColumns'));

        var mapTypes = localStorage.getItem('mapColumns');
        var mapTypes = JSON.parse('[' + mapTypes + ']');
        var sideCharts = [];
        mapTypes.forEach(function (element) {
            if (element.value == 'Mapa') {
                mapColumns.push(element.key);
            } else {
                sideCharts.push(element);
            }
        });

        sideCharts.sort(function (a, b) { return (a.option > b.option) ? 1 : ((b.option > a.option) ? -1 : 0); });

        if (mapColumns.length == 1) {
            multiMap = false;
            init(defineClusterIconAsBarChart);
        } else {
            multiMap = true;
            init(defineClusterIconAsBarChartTestDiffVars);
            //document.getElementById("buttonUpdateChart").parentNode.removeChild(document.getElementById("buttonUpdateChart"));
        }
        var everything;

        // console.log(mapColumns);


        //    d3.json('earthquakes.geojson', function (data) {
        function init(kkk) {
            // console.log(chartType);
            // console.log('File being loaded: ' + localStorage.getItem('file'));
            console.log(localStorage.getItem('file'));
            console.log(localStorage.getItem('file').substring(12, localStorage.getItem('file').length));
            d3.csv(localStorage.getItem('file').substring(12, localStorage.getItem('file').length), function (error, data) {
                //d3.csv(localStorage.getItem('file'), function (error, data) {
                // d3.csv(localStorage.getItem('file').substring(12, localStorage.getItem('file').length), function (error, data) {
                if (!error) {
                    // geojson = data;

                    
                    if (typeof chartType == 'undefined') {
                        console.log('mapColumns.length: ' + mapColumns.length);
                        if (mapColumns.length == 1) {
                            chartType = defineClusterIconAsBarChart;
                        } else {
                            chartType = defineClusterIconAsBarChartTestDiffVars;
                        }
                    }
                    //console.log('chartType: ' + chartType);

                    makeGeoJSON(data);
                    data = geojson;
                    console.log(data);

                    // load all possible columns
                    metadata = geojson.features[0].properties;
                    for (var key in metadata) {
                        columns.push(key);
                    }

                    // get distinct of values for the column selected for map
                    mapColumnDistinct = _.keys(_.countBy(geojson.features, function (d) {
                        return d.properties[mapColumns[0]];
                    }));

                    mapColumnDistinct.sort(function (a, b) { return (a > b) ? 1 : ((b > a) ? -1 : 0); });

                    // console.log(mapColumnDistinct);

                    //create crossfilter and dimensions
                    var filter = crossfilter(data.features)
                    var all = filter.groupAll();
                    everything = filter.dimension(function (d) {
                        return d
                    })
                    var geomDimension = filter.dimension(function (d) {
                        return d.geometry
                    })
                    var markers = L.geoJson(geomDimension.top(Infinity), {
                        pointToLayer: defineFeature,
                        onEachFeature: defineFeaturePopup
                    }, {
                            pointToLayer: function (feature, latlng) {
                                return L.circleMarker(latlng, {
                                    radius: 4,
                                    fillColor: "steelblue",
                                    color: "#fff",
                                    weight: 1,
                                    opacity: 1,
                                    fillOpacity: 0.8
                                })
                                    .bindPopup(feature.properties['FERIDOS'].toString()); //TODO
                            }
                        });
                    console.log(chartType);
                    markerclusters = L.markerClusterGroup({
                        maxClusterRadius: 2 * rmax,
                        iconCreateFunction: chartType
                    });
                    map.addLayer(markerclusters);
                    markerclusters.addLayer(markers);
                    map.fitBounds(markers.getBounds());
                    map.attributionControl.addAttribution(metadata.attribution);
                    renderLegend();


                    // chart 1

                    for (var i = 0; i < sideCharts.length; i++) {
                        chartType = sideCharts[i].value;
                        var divPosition = '#chart-' + parseFloat(i + 1);
                        document.getElementById(divPosition.replace("#", "") + '-title').innerHTML = sideCharts[i].key;
                        if (chartType == 'Barra') {
                            createBarChart(sideCharts[i].key, filter, markers, markerclusters, divPosition);
                        } else if (chartType == 'Linha') {
                            createLineChart(sideCharts[i].key, filter, markers, markerclusters, divPosition);
                        } else if (chartType == 'Pizza') {
                            createPizzaChart(sideCharts[i].key, filter, markers, markerclusters, divPosition);
                        } else if (chartType == 'Donut') {
                            createPieChart(sideCharts[i].key, filter, markers, markerclusters, divPosition);
                        }

                    }

                    var earthquakeCount = dc.dataCount('.dc-data-count')
                    earthquakeCount
                        .dimension(filter)
                        .group(all)
                        .html({
                            //some: '<strong>%filter-count</strong> records selected from a total of <strong>%total-count</strong>' +
                            //    ' | <a href=\'javascript:dc.filterAll(); dc.renderAll();\'>Reset All</a>',
                            some: '<strong>%filter-count</strong> registros selecionados de um total de <strong>%total-count</strong>' +
                                ' | <a href=\'javascript:dc.filterAll(); dc.renderAll();\'>Resetar</a>',
                            all: 'Todos registros selecionados. Selecione um gráfico ou interaja com o mapa para aplicar filtros.'
                            //all: 'All records selected. Select a chart or interact with the map to apply filters.'
                        });

                    dc.renderAll();

                    //chart listeners
                    // depthChart.on('filtered', function (chart, filter) {
                    //     updateMap()
                    // });
                    // dateChart.on('filtered', function (chart, filter) {
                    //     updateMap()
                    // });
                    // regiaoChart.on('filtered', function (chart, filter) {
                    //     updateMap()
                    // });
                    // tempoChart.on('filtered', function (chart, filter) {
                    //     updateMap()
                    // });
                    // function updateMap() {
                    //     markers.clearLayers()
                    //     markers.addData({
                    //         type: 'FeatureCollection',
                    //         features: everything.top(Infinity)
                    //     });
                    //     markerclusters.clearLayers();
                    //     markerclusters.addLayer(markers);
                    // }

                    //map listeners
                    map.on('moveend', function () {
                        updateMapFilter()
                    })
                    map.on('zoomend', function () {
                        updateMapFilter()
                    })
                    function updateMapFilter() {
                        var bounds = map.getBounds(),
                            n = bounds._northEast.lat,
                            e = bounds._northEast.lng,
                            s = bounds._southWest.lat,
                            w = bounds._southWest.lng;
                        var boundsFeature = {
                            type: 'Feature',
                            geometry: {
                                type: 'Polygon',
                                coordinates: [
                                    [[w, s],
                                    [w, n],
                                    [e, n],
                                    [e, s],
                                    [w, s]]
                                ]
                            }
                        }
                        geomDimension.filter(function (d) {
                            //make feature
                            var point = {
                                type: 'Feature',
                                geometry: d
                            }
                            return turf.inside(point, boundsFeature)
                        })
                        dc.redrawAll();
                    }
                } else {
                    console.log('Could not load data...');
                }
            });
        }

        function makeGeoJSON(csvData) {
            console.log(csvData);
            csv2geojson.csv2geojson(csvData, {
                latfield: 'LATITUDE',
                lonfield: 'LONGITUDE',
                delimiter: ','
            }, function (err, data) {
                // console.log(data);
                geojson = data;
            });
        }

        function createBarChart(columnName, filter, markers, markerclusters, location) {
            console.log(columnName);
            var magDimension = filter.dimension(function (d) {
                return d.properties[columnName]
            });

            var magDimensionGroup = magDimension.group();

            var magChart = dc.barChart(location);
            magChart
                .height(180)
                .margins({ top: 10, right: 50, bottom: 30, left: 40 })
                .dimension(magDimension)
                .group(magDimensionGroup)
                .elasticY(true)
                .ordering(function (d) { return -d.value; })
                .x(d3.scale.ordinal())
                .xUnits(dc.units.ordinal)
                .yAxis()
                .ticks(3);

            magChart.on('filtered', function (chart, filter) {
                updateMap()
            });

            function updateMap() {
                markers.clearLayers()
                markers.addData({
                    type: 'FeatureCollection',
                    features: everything.top(Infinity)
                });
                markerclusters.clearLayers();
                markerclusters.addLayer(markers);
            }

        }

        function createLineChart(columnName, filter, markers, markerclusters, location) {
            console.log(columnName);

            // var dtgFormat = d3.time.format("%Y-%m-%dT%H:%M:%S");
            // var dtgFormat2 = d3.time.format("%a %e %b %H:%M");

            // var dtg1 = d.properties[columnName].substr(0,10) + " " + d.origintime.substr(11,8);
            // var dtg = dtgFormat.parse(d.properties[columnName].substr(0,19)); 

            var dateDimension = filter.dimension(function (d) {
                return d3.time.day(new Date(d.properties[columnName]))
            });
            var dateDimensionGroup = dateDimension.group();

            var dateChart = dc.lineChart(location);
            dateChart
                .renderArea(true)
                .height(180)
                .transitionDuration(1000)
                .margins({ top: 30, right: 30, bottom: 55, left: 50 })
                .dimension(dateDimension)
                .group(dateDimensionGroup)
                .elasticY(true)
                .x(d3.time.scale().domain([new Date(2015, 12, 31), new Date(2016, 12, 31)]))
                .xUnits(d3.time.days)
                .renderlet(function (chart) {
                    chart.selectAll("g.x text")
                        .attr('dx', '-30')
                        .attr('transform', "rotate(-30)");
                });;

            dateChart.on('filtered', function (chart, filter) {
                updateMap()
            });

            function updateMap() {
                markers.clearLayers()
                markers.addData({
                    type: 'FeatureCollection',
                    features: everything.top(Infinity)
                });
                markerclusters.clearLayers();
                markerclusters.addLayer(markers);
            }
        }

        function createPizzaChart(columnName, filter, markers, markerclusters, location) {
            var tempoDimension = filter.dimension(function (d) {
                return d.properties[columnName];
            });
            var tempoDimensionGroup = tempoDimension.group();

            var tempoChart = dc.pieChart(location)
            tempoChart
                .height(180)
                .dimension(tempoDimension)
                .group(tempoDimensionGroup);

            tempoChart.on('filtered', function (chart, filter) {
                updateMap()
            });

            function updateMap() {
                markers.clearLayers()
                markers.addData({
                    type: 'FeatureCollection',
                    features: everything.top(Infinity)
                });
                markerclusters.clearLayers();
                markerclusters.addLayer(markers);
            }

        }

        function createPieChart(columnName, filter, markers, markerclusters, location) {
            var regiaoDimension = filter.dimension(function (d) {
                return d.properties[columnName];
            });
            var regiaoDimensionGroup = regiaoDimension.group();

            var regiaoChart = dc.pieChart(location)
            regiaoChart
                .height(180)
                .dimension(regiaoDimension)
                .group(regiaoDimensionGroup)
                .innerRadius(40);

            regiaoChart.on('filtered', function (chart, filter) {
                updateMap()
            });

            function updateMap() {
                markers.clearLayers()
                markers.addData({
                    type: 'FeatureCollection',
                    features: everything.top(Infinity)
                });
                markerclusters.clearLayers();
                markerclusters.addLayer(markers);
            }
        }

        function defineClusterIconAsBarChart(cluster) {

            console.log('defineClusterIconAsBarChart');
            var children = cluster.getAllChildMarkers();

            var n = children.length,
                strokeWidth = 1;
            var dataset = d3.nest() //Build a dataset for the pie chart
                .key(function (d) {
                    return d.feature.properties[mapColumns[0]];
                })
                .entries(children, d3.map);

            var r = 30 - 2 * 1 - (n < 10 ? 12 : n < 100 ? 8 : n < 1000 ? 4 : 0), //Calculate clusterpie radius...
                origo = (r + 1), //Center coordinate
                w = origo * 2, //width and height of the svg element
                h = w,
                iconDim = (r + 1) * 2;

            mapColumnDistinct.forEach(function (entry) {
                dataset.push({ "key": entry, "values": [] });
            });

            // order starts always from a to z
            dataset.sort(function (a, b) { return (a.key > b.key) ? 1 : ((b.key > a.key) ? -1 : 0); });

            // console.log(mapColumnDistinct);

            var x = d3.scale.ordinal().rangeRoundBands([0, w], 0.1);
            var y = d3.scale.linear().range([h, 0]);
            x.domain(dataset.map(function (d) {
                return d.key;
            }));
            y.domain([0, d3.max(dataset, function (d) {
                return d.values.length;
            })]);
            // create a svg element
            var svg = document.createElementNS(d3.ns.prefix.svg, 'svg');
            // update w according bars > 0
            var vis = d3.select(svg)
                .attr("width", w)
                .attr("height", h)
                .append('g')
                .attr('transform', 'translate(' + (h / 200) + ',' + (w / 200) + ')'); //center g

            vis.selectAll(".bar")
                .data(dataset)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr('class', function (d) {
                    return "category-" + parseFloat(mapColumnDistinct.indexOf(d.key) + 1);
                })
                .attr("x", function (d) {
                    return x(d.key);
                })
                .attr("y", function (d) {
                    return y(d.values.length);
                })
                // define the width of each bar
                .attr("width", x.rangeBand())
                .attr("text", function (d) {
                    return d.key;
                })
                //.on('mouseover', tip.show)
                //.on('mouseout', tip.hide)
                .attr("height", function (d) {
                    return h - y(d.values.length);
                })
                .append('svg:title')
                .text(function (d) {
                    // console.log(d);
                    //return d.key + ' (' + d.values.length + ' record' + (d.values.length != 1 ? 's' : '') + ')';
                    return d.key + ' (' + d.values.length + ' registro' + (d.values.length != 1 ? 's' : '') + ')';
                    // return d.key + ' (' + d.values.length + ' ACIDENTE' + (d.values.length != 1 ? 'S' : '') + ')';
                });
            // add the x Axis
            vis.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + h + ")")
                //.attr("width", w/dataset.length)
                ;//.call(d3.axisBottom(x));
            // add the y Axis
            vis.append("g")
                .attr("class", "y axis")
                ;//.call(d3.axisLeft(y));
            vis.append('text')
                .attr('x', origo)
                .attr('y', origo)
                .attr('class', 'marker-cluster-bar-label')
                .attr('text-anchor', 'middle')
                .attr('dy', '.3em')
                .text(n);
            var html = serializeXmlNode(svg);
            var myIcon = new L.DivIcon({
                html: html,
                className: 'mycluster',
                iconSize: new L.Point(iconDim, iconDim)
            });
            return myIcon;
        }

        function defineClusterIcon(cluster) {
            console.log('defineClusterIcon');
            var children = cluster.getAllChildMarkers(),
                n = children.length, //Get number of markers in cluster
                strokeWidth = 1, //Set clusterpie stroke width
                r = rmax - 2 * strokeWidth - (n < 10 ? 12 : n < 100 ? 8 : n < 1000 ? 4 : 0), //Calculate clusterpie radius...
                iconDim = (r + strokeWidth) * 2, //...and divIcon dimensions (leaflet really want to know the size)
                data = d3.nest() //Build a dataset for the pie chart
                    .key(function (d) {
                        return d.feature.properties[mapColumns[0]];
                    })
                    .entries(children, d3.map),
                //bake some svg markup
                html = bakeThePie({
                    data: data,
                    valueFunc: function (d) {
                        return d.values.length;
                    },
                    strokeWidth: 1,
                    outerRadius: r,
                    innerRadius: r - 10,
                    pieClass: 'cluster-pie',
                    pieLabel: n,
                    pieLabelClass: 'marker-cluster-pie-label',
                    pathClassFunc: function (d) {
                        return "category-" + parseFloat(mapColumnDistinct.indexOf(d.data.key) + 1);
                    },
                    pathTitleFunc: function (d) {
                        // return 'Soma de ' + (isNaN(d.id) ? d.id.toLowerCase() : d.id) + ': ' + d.value + ' (' + children.length
                        // + ' registro' + (children.length != 1 ? 's' : '') + ')';
                        // console.log(d.data);
                        // return mapColumns[0] + ' (' + d.data.values.length + ' registro' + (d.data.values.length != 1 ? 's' : '') + ')';
                        //return d.data.key + ' (' + d.data.values.length + ' record' + (d.data.values.length != 1 ? 's' : '') + ')';
                        return d.data.key + ' (' + d.data.values.length + ' registro' + (d.data.values.length != 1 ? 's' : '') + ')';
                    }
                }),
                //Create a new divIcon and assign the svg markup to the html property
                myIcon = new L.DivIcon({
                    html: html,
                    className: 'marker-cluster',
                    iconSize: new L.Point(iconDim, iconDim)
                });
            return myIcon;
        }

        function defineClusterIconAsBarChartTestDiffVars(cluster) {
            var children = cluster.getAllChildMarkers();

            //console.log('defineClusterIconAsBarChartTestDiffVars');

            var n = children.length,
                strokeWidth = 1;
            var dataset = d3.nest() //Build a dataset for the pie chart
                .key(function (d) {
                    return d.feature.properties[categoryField];
                })
                .entries(children, d3.map);

            // TODO start getting map variables
            var r = 30 - 2 * 1 - (n < 10 ? 12 : n < 100 ? 8 : n < 1000 ? 4 : 0), //Calculate clusterpie radius...
                origo = (r + 1), //Center coordinate
                w = origo * 2, //width and height of the svg element
                h = w,
                iconDim = (r + 1) * 2;

            var items = [];

            var clusterdataset = [];
            var tempo = 0;
            var feridos = 0;
            var hora = 0;


            for (var i = 0; i < mapColumns.length; i++) {
                //field_ + i = mapColumns[i];
                //objects[i] = { "id":mapColumns[i], "value":0};
                // objects.push({ "id": mapColumns[i], "value": 0 });
                if (objects.length != mapColumns.length) {
                    objects.push({ "id": mapColumns[i], "value": 0 });
                }
            }

            //console.log('defineClusterIconAsBarChartTestDiffVars');
            children.forEach(function (cluster) {
                tempo = 0;
                feridos = 0;
                hora = 0;

                mapColumns.forEach(function (element) {

                    if (element != 'LATITUDE' && element != 'LONGITUDE') {
                        objects.forEach(function (obj) {
                            if (obj.id == element) {
                                obj.value = parseFloat(obj.value) + parseFloat(cluster.feature.properties[element]);
                            }
                        });
                    }
                });
            });
            
            var x = d3.scale.ordinal().rangeRoundBands([0, w], 0.1);
            var y = d3.scale.linear().range([h, 0]);
            x.domain(objects.map(function (d) {
                return d.id;
            }));
            y.domain([0, d3.max(objects, function (d) {
                return d.value;
            })]);
            // create a svg element
            var svg = document.createElementNS(d3.ns.prefix.svg, 'svg');
            // update w according bars > 0
            var vis = d3.select(svg)
                .attr("width", w)
                .attr("height", h)
                .append('g')
                .attr('transform', 'translate(' + (h / 200) + ',' + (w / 200) + ')'); //center g

            //console.log('objects: ' , objects);

            vis.selectAll(".bar")
                .data(objects)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr('class', function (d) {
                    return "category-" + parseFloat(mapColumns.indexOf(d.id) + 1);
                })
                .attr("x", function (d) {
                    return x(d.id);
                })
                .attr("y", function (d) {
                    return y(d.value);
                })
                // define the width of each bar
                .attr("width", x.rangeBand())
                .attr("text", function (d) {
                    return d.id;
                })
                //.on('mouseover', tip.show)
                //.on('mouseout', tip.hide)
                .attr("height", function (d) {
                    return h - y(d.value);
                })
                .append('svg:title')
                .text(function (d) {
                    //return 'Sum of ' + (isNaN(d.id) ? d.id.toLowerCase() : d.id) + ': ' + d.value + ' (' + children.length
                    //    + ' record' + (children.length != 1 ? 's' : '') + ')';

                    return 'Soma de ' + (isNaN(d.id) ? d.id.toLowerCase() : d.id) + ': ' + d.value + ' (' + children.length
                    + ' registro' + (children.length != 1 ? 's' : '') + ')';
                });
            // add the x Axis
            vis.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + h + ")")
                //.attr("width", w/dataset.length)
                ;//.call(d3.axisBottom(x));
            // add the y Axis
            vis.append("g")
                .attr("class", "y axis")
                ;//.call(d3.axisLeft(y));
            vis.append('text')
                .attr('x', origo)
                .attr('y', origo)
                .attr('class', 'marker-cluster-bar-label')
                .attr('text-anchor', 'middle')
                .attr('dy', '.3em')
                .text(n);
            var html = serializeXmlNode(svg);
            var myIcon = new L.DivIcon({
                html: html,
                className: 'mycluster',
                iconSize: new L.Point(iconDim, iconDim)
            });
            return myIcon;
        }

        function renderLegend() {
            //TODO here
            var legendValues = [];
            var legendTitle;
            if (mapColumns.length == 1) {
                // check if there are other columns
                // if so the approach needs to change to numbers instead of strings
                legendValues = mapColumnDistinct;
                legendTitle = mapColumns[0];
                
                legendValues.sort(function (a, b) { return (a > b) ? 1 : ((b > a) ? -1 : 0); });
            } else {
                legendValues = mapColumns;
                legendTitle = 'Atrib. por barra';
            }

            //console.log(legendValues);

            // console.log(d3.entries(mapColumnDistinct));
            var data = d3.entries(legendValues),
                legenddiv = d3.select('body').append('div')
                    .attr('id', 'legend');
            var heading = legenddiv.append('div')
                .classed('legendheading', true)
                .text(legendTitle);
            var legenditems = legenddiv.selectAll('.legenditem')
                .data(data);

            legenditems
                .enter()
                .append('div')
                .attr('class', function (d) {
                    if (mapColumns.length > 1) {
                        return "category-" + parseFloat(mapColumns.indexOf(d.value) + 1);
                    } else {
                        var numb = parseFloat(legendValues.indexOf(d.value) + 1);
                        return 'category-' + numb;
                    }
                })
                .classed({ 'legenditem': true })
                .text(function (d) {
                    return d.value;
                });
        }
        /*Helper function*/
        function serializeXmlNode(xmlNode) {
            if (typeof window.XMLSerializer != "undefined") {
                return (new window.XMLSerializer()).serializeToString(xmlNode);
            } else if (typeof xmlNode.xml != "undefined") {
                return xmlNode.xml;
            }
            return "";
        }
        /*function that generates a svg markup for the pie chart*/
        function bakeThePie(options) {
            /*data and valueFunc are required*/
            if (!options.data || !options.valueFunc) {
                return '';
            }
            var data = options.data,
                valueFunc = options.valueFunc,
                r = options.outerRadius ? options.outerRadius : 8, //Default outer radius = 28px
                rInner = options.innerRadius ? options.innerRadius : r - 10, //Default inner radius = r-10
                strokeWidth = options.strokeWidth ? options.strokeWidth : 1, //Default stroke is 1
                pathClassFunc = options.pathClassFunc ? options.pathClassFunc : function () {
                    return '';
                }, //Class for each path
                pathTitleFunc = options.pathTitleFunc ? options.pathTitleFunc : function () {
                    return '';
                }, //Title for each path
                pieClass = options.pieClass ? options.pieClass : 'marker-cluster-pie', //Class for the whole pie
                pieLabel = options.pieLabel ? options.pieLabel : d3.sum(data, valueFunc), //Label for the whole pie
                pieLabelClass = options.pieLabelClass ? options.pieLabelClass : 'marker-cluster-pie-label',//Class for the pie label
                origo = (r + strokeWidth), //Center coordinate
                w = origo * 2, //width and height of the svg element
                h = w,
                donut = d3.layout.pie(),
                arc = d3.svg.arc().innerRadius(rInner).outerRadius(r);
            //Create an svg element
            var svg = document.createElementNS(d3.ns.prefix.svg, 'svg');
            //Create the pie chart
            var vis = d3.select(svg)
                .data([data])
                .attr('class', pieClass)
                .attr('width', w)
                .attr('height', h);
            var arcs = vis.selectAll('g.arc')
                .data(donut.value(valueFunc))
                .enter().append('svg:g')
                .attr('class', 'arc')
                .attr('transform', 'translate(' + origo + ',' + origo + ')');
            arcs.append('svg:path')
                .attr('class', pathClassFunc)
                .attr('stroke-width', strokeWidth)
                .attr('d', arc)
                .append('svg:title')
                .text(pathTitleFunc);
            vis.append('text')
                .attr('x', origo)
                .attr('y', origo)
                .attr('class', pieLabelClass)
                .attr('text-anchor', 'middle')
                //.attr('dominant-baseline', 'central')
                /*IE doesn't seem to support dominant-baseline, but setting dy to .3em does the trick*/
                .attr('dy', '.3em')
                .text(pieLabel);
            //console.log(svg);
            return serializeXmlNode(svg);
        }
        function defineFeature(feature, latlng) {
            var categoryVal = mapColumns[0];//feature.properties[categoryField],
            // iconVal = feature.properties[iconField];
            //iconVal = mapColumns[0];
            var categoryVal;

            if (multiMap == true) {
                categoryVal = objects.indexOf(feature.properties[mapColumns[0]]);
            } else {
                categoryVal = 0;
            }

            // no icon val for now
            //var myClass = 'marker category-' + categoryVal + ' icon-' + iconVal;
            var myClass = 'marker category-' + parseFloat(categoryVal + 1);
            var myIcon = L.divIcon({
                className: myClass,
                iconSize: null
            });
            return L.marker(latlng, { icon: myIcon });
        }
        function defineFeaturePopup(feature, layer) {
            var props = feature.properties,
                fields = metadata.fields,
                popupContent = '';

            //console.log(columns);
            // popupFields.map(function (key) {
            columns.map(function (key) {
                if (props[key]) {
                    // console.log(props[key]);
                    var val = props[key],
                        label = props[key];

                    // if (fields[key].lookup) {
                    //     val = fields[key].lookup[val];
                    // }

                    mapTypes.forEach(function (element) {
                        if (element.key == key) {
                            if (typeof (val) != 'undefined') {
                                popupContent += '<span class="attribute"><span class="label" style="color: #000000">' + key + ':</span> ' + val + '</span>';
                            }
                        }
                    });


                }
            });
            popupContent = '<div class="map-popup">' + popupContent + '</div>';
            layer.bindPopup(popupContent, { offset: L.point(1, -2) });
        }
        function changeChart() {
            markerclusters.clearLayers();
            if (document.getElementById("buttonUpdateChart").innerText == 'Bar chart') {
                document.getElementById("buttonUpdateChart").innerText = 'Donut chart';
                chartType = defineClusterIconAsBarChart;
                init(defineClusterIconAsBarChart);
            } else {
                document.getElementById("buttonUpdateChart").innerText = 'Bar chart';
                chartType = defineClusterIcon;
                init(defineClusterIcon);
            }
        }
    </script>

</body>

</html>